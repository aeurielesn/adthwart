<html>
<script type="text/javascript">
var abp = {};
</script>
<script type="text/javascript" src="adblockplus/chrome/content/filterClasses.js"/>
<script type="text/javascript" src="adblockplus/chrome/content/filterStorage.js"/>
<script type="text/javascript" src="adblockplus/chrome/content/elemhide.js"/>
<script type="text/javascript" src="adblockplus/chrome/content/filterListener.js"/>
<script type="text/javascript" src="adblockplus/chrome/content/matcher.js"/>
<script type="text/javascript" src="filterupdate.js"/>
<script>

// Special-case domains for which we should only inject their specific
// selectors, due to Chrome selector handling bugginess
// TODO: Put this in the AdThwart filter list, like !NI
var onlyInjectDomainSpecificSelectors = {"mail.google.com": true};

// Caches the last answer for isDomainExcluded()
var lastDomainChecked = "";
var lastDomainExcluded = false;
// Last set of user-specified click-to-hide filters
var clickHideFilters = null;
var clickHideActive = false;
// List of URLs currently being downloaded; used to prevent multiple requests
// for the same URL from actually causing multiple downloads
var downloading = {};

// Extracts a domain name from a URL
function extractDomainFromURL(url) {
    if(!url) return "";
    x = url.substr(url.indexOf("://") + 3);
    x = x.substr(0, x.indexOf("/"));
    x = x.substr(x.indexOf("@") + 1);
    colPos = x.indexOf(":");
    if(colPos >= 0)
        x = x.substr(0, colPos);
    return x;
}

// Returns an associative array object of the given name loaded from localStorage.
// We do this because apparently localStorage only does strings, so we have to
// JSONify everything
function getOptionsObject(optName) {
    var thing = localStorage[optName];
    if(typeof thing != "string") {
        // Initialize storage
        localStorage[optName] = JSON.stringify({});
        return {};
    }
    var parsed = JSON.parse(thing);
    return parsed;
}

// JSONifies and saves an associative array object in localStorage
function saveOptionsObject(optName, data) {
    localStorage[optName] = JSON.stringify(data);
}

// Returns true if the specified option is defined in localStorage
function optionExists(opt) {
    return (typeof localStorage[opt] != "undefined");
}

// Checks whether the option exists in localStorage, and if it doesn't, set it to
// the specified value
function defaultOptionValue(opt, val) {
    if(!optionExists(opt))
        localStorage[opt] = val;
}

// Sets options to defaults, upgrading old options from previous versions as necessary
function setDefaultOptions() {
   // We're not giving the users these options anymore.
   // Assuming little backlash we'll remove all code mentioning these
   // options in a future revision.
   localStorage["initialHideFlash"] = "true";
   localStorage["initialHideImg"] = "false";
   localStorage["initialHideIframe"] = "true";
   defaultOptionValue("disableInlineTextAds", "true");
   defaultOptionValue("specialCaseYouTube", "true");
   defaultOptionValue("excludedDomains", JSON.stringify({"acid3.acidtests.org": true}));

   // If user had older version installed, set new options accordingly and remove old options
   if(optionExists("experimental")) {
       if(localStorage["experimental"] == "false") {
           localStorage["initialHideFlash"] = "false";
           localStorage["initialHideImg"] = "false";
           localStorage["initialHideIframe"] = "false";
       }
       delete localStorage["experimental"];
   }
}

// Upgrade options before we do anything else.
setDefaultOptions(); 

// Adds a specified filter to the list of user filters
function addFilter(filterText) {
    var userFilters = localStorage["userFilters"];
    if(typeof userFilters == "undefined")
        userFilters = JSON.stringify(["qux.us###annoying_AdDiv", "qux.us##.ad_class"]);
    userFilters = JSON.parse(userFilters);
    userFilters.push(filterText);
    localStorage["userFilters"] = JSON.stringify(userFilters);
    abp.filterListener.addFilter(Filter.fromText(filterText));
}

// Enables ad blocking for the specified domain
function removeDomainFromExclusionList(domain) {
    var excludedDomains = getOptionsObject("excludedDomains");
    if(domain in excludedDomains) {
        delete excludedDomains[domain];
    }
    saveOptionsObject("excludedDomains", excludedDomains);
    lastDomainChecked = "";
}

// Disables ad blocking for the specified domain
function addDomainToExclusionList(domain) {
    var excludedDomains = getOptionsObject("excludedDomains");
    excludedDomains[domain.toLowerCase()] = true;
    saveOptionsObject("excludedDomains", excludedDomains);
    lastDomainChecked = "";
}

// Returns true if this domain or any parent domain is in the exclusion list
function isDomainExcluded(docDomain) {
    if(!docDomain)
        return false;
        
    docDomain = docDomain.replace(/\.+$/, "").toLowerCase();

    // Cache the last domain that was asked for so we don't
    // do all this JSON nonsense on every query
    if(docDomain == lastDomainChecked)
        return lastDomainExcluded;
    var excludedDomains = getOptionsObject("excludedDomains");
    lastDomainChecked = docDomain;

    while (true) {
        if (docDomain in excludedDomains) {
            lastDomainExcluded = true;
            return true;
        }

        var nextDot = docDomain.indexOf(".");
        if (nextDot < 0)
            break;
        docDomain = docDomain.substr(nextDot + 1);
    }
    lastDomainExcluded = false;
    return false;
}

function isDomainInList(domain, listName) {
    if(!domain)
        return false;

    var list = getOptionsObject(listName);
        
    domain = domain.replace(/\.+$/, "").toLowerCase();

    while (true) {
        if (domain in list) return true;
        var nextDot = domain.indexOf(".");
        if (nextDot < 0) break;
        domain = domain.substr(nextDot + 1);
    }
    return false;
}

// Toggles whether ad blocking is turned on for the domain the given tab is showing
function toggleDomainExclusion(tabId) {
    chrome.tabs.sendRequest(tabId, {reqtype: "get-domain"}, function(response) {
        var excluded = isDomainExcluded(response.domain);
        if(excluded)
            removeDomainFromExclusionList(response.domain);
        else
            addDomainToExclusionList(response.domain);
    });
}

function refreshIconByTabId(tabId) {
    chrome.tabs.get(tabId, function(tab) { refreshIcon(tab)});
}

// Adds or removes page action icon according to options.
// Show devil if enabled, apathetic face otherwise.
function refreshIcon(tab) {
    var domain = extractDomainFromURL(tab.url);
    var excluded = isDomainExcluded(domain);
    iconFilename = excluded ? "icons/face-plain-19.png" : "icons/face-devilish-19.png";
    chrome.pageAction.setIcon({tabId: tab.id, path: iconFilename});
    var title = "AdThwart is " + (excluded ? "disabled" : "enabled") + " for " + domain;
    // Don't show icon for chrome*:// pages
    if(tab.url.substring(0, 6) != "chrome") {
        chrome.pageAction.setTitle({tabId: tab.id, title: title});
        var shouldShowIcon = localStorage["shouldShowIcon"];
        if(typeof shouldShowIcon != "undefined" && shouldShowIcon == "false") {
            chrome.pageAction.hide(tab.id);
        } else {
            chrome.pageAction.show(tab.id);
        }
    }
}

// The general strategy here is to load the filters and set up the machinery for
// deciding whether to block a given element once here, and let content scripts
// query us about individual elements.

// Downloads a filter list from a particular URL
function downloadFilterList(url) {
    downloading[url] = true;
    new FilterListFetcher(url, function(fetcher) {
        if(!fetcher.error) {
            // Take this URL out of currently-being-downloaded list
            delete downloading[url];
            reloadFilters();
        }
    });
}

// Loads the filter list from disk (or localStorage) and stores it in a global variable
function loadFiltersRawText(filename) {
    // Check filename for http prefix and if so load from localStorage instead
    if(filename.match(/^http/)) {
        if(typeof localStorage[filename] == "string") {
            var list = JSON.parse(localStorage[filename]);
            // If there was an error loading the list before, don't try again now, let the user
            // update manually. This is so we won't pound a filter list's server if the
            // maintainer moves the file.
            if(!list.error) {
                // Check whether it's time to redownload the list.
                // If list specifies its expiry time, use that. Otherwise default to 3 days.
                var now = new Date().getTime();
                var expires = list.expires ? list.expires : DEFAULT_EXPIRE_TIME;
                // If the list is expired and we aren't currently downloading it already, redownload it.
                if(((now - list.lastUpdated) > expires) && !downloading[filename]) {
                    console.log("Too old, so redownloading " + filename);
                    downloadFilterList(filename);
                }
            }
            // If there is any text for the filter list, return it, otherwise return a
            // blank string rather than undefined. This depends on the fetcher not
            // filling list.text with garbage on an unsuccessful fetch.
            return list.text ? list.text : "";
        } else {
            // This filter list was never downloaded, so download it
            // This is kept from running away by the fetcher actually storing the filter
            // list data, which is checked for above.
            console.log("First time download: " + filename);
            downloadFilterList(filename);           
            return ""; // Return nothing for now, it'll be reloaded later
        }
    }
    
    // I guess we have to load local files through XMLHttpRequest?
    // Who knows, I'm not very good at this anyhow.
    listUrl = chrome.extension.getURL("lists/" + filename);
    var xhr = new XMLHttpRequest();
    xhr.open("GET", listUrl, false);
    xhr.send(null);
    return xhr.responseText;
}

// Clears the ABP matchers of filters and reloads them.
// This will also download and cache filter lists as necessary.
function reloadFilters() {
    abp.filterListener.clear();
    saveOptionsObject("noCSSInjectDomains", {}); // Clear no-inject list
    var urlsToLoad = new Array();
    
    // Make sure user filter URLs are in filterFiles
    loadUserFilterURLs();

    // filterFilesEnabled is a bit of a misnomer - can include URLs too, and it
    // includes the enabled state of the particular filter set.
    // But if we change it, we'll break current installations
    var filterFilesEnabled = typeof localStorage["filterFilesEnabled"] == "string" ? JSON.parse(localStorage["filterFilesEnabled"]) : {};

    // Previous versions didn't store info about EasyList and extras.txt, so turn them on by default.
    if(!("easylist" in filterFilesEnabled)) {
        filterFilesEnabled["easylist"] = true;
        filterFilesEnabled["extras"] = true;
        localStorage["filterFilesEnabled"] = JSON.stringify(filterFilesEnabled);
    }
    
    // We've gotten rid of Fanboy's list, so migrate those users to EasyList
    if(filterFilesEnabled["fanboy"] == true) {
        filterFilesEnabled["easylist"] = true;
        delete filterFilesEnabled["fanboy"];
        localStorage["filterFilesEnabled"] = JSON.stringify(filterFilesEnabled);
    }

    for(var key in filterFilesEnabled) {
        if(filterFilesEnabled[key])
            urlsToLoad.push(filterFiles[key]);
    }
    
    for(var j = 0; j < urlsToLoad.length; j++) {
        var FiltersRawText = loadFiltersRawText(urlsToLoad[j]);
        // Shove it over to the ABP code to parse
        var filters = FiltersRawText.split('\n');
        for (i in filters) {
            // Remove any extra newline-type characters
            f = filters[i].replace(/[\r\n]/, '');
            // Ignore zero-length and commented-out lines
            if(f.length == 0)
                continue;
            
            switch(f[0]) {
                case '[':
                    continue;
                case '!':
                    // Handle no-CSS-inject domains. This is a workaround for a Chrome bug
                    // that breaks site layouts when a stylesheet is injected.
                    var x;
                    if(x = f.match(/^!NI (.+)$/)) {
                        ni = getOptionsObject("noCSSInjectDomains");
                        ni[x[1]] = true;
                        saveOptionsObject("noCSSInjectDomains", ni);
                    }
                    continue;
            }

            // XXX: Special-case ignoring rules that cause strange effects
            // These ruin CC/BCC in Gmail by preventing display of those fields...somehow.
            // Possibly a Chrome bug. For example:
            // ~all.google.domains##div[style="font-size: small; background-color: rgb(255, 249, 221);"]
            if(f.match(/all.google.domains.+rgb/))
                continue;

            // XXX: Special-case certain filters that break airmiles.ca, probably
            // due to broken interactions of Chrome's CSS selector engine with our
            // inserted stylesheet
            // TODO: Appears to be fixed in Chromium as of 5.0.317.0 (38075), so
            // remove this special case when stable Chrome catches up
            if(f.indexOf('a[href^="') == 2)
                f = "~airmiles.ca" + f;

            abp.filterListener.addFilter(Filter.fromText(f));
        }
    }
    
    // Add user filters
    userFilters = localStorage["userFilters"];
    if(typeof userFilters != "undefined") {
        userFilters = JSON.parse(userFilters);
        for(var i = 0; i < userFilters.length; i++) {
            abp.filterListener.addFilter(Filter.fromText(userFilters[i]));
        }
    }
}

reloadFilters();

// Respond to requests about whether to block particular DOM elements
// We'll use a "long-lived" connection since we'll be asked about tons of elements
chrome.extension.onConnect.addListener(function(port) {
    port.onMessage.addListener(function(msg) {
        if(msg.reqtype == "should-block-list?") {
            var numElements = msg.urls.length;
            blockList = new Array();
            for(var i = 0; i < numElements; i++) {
                // TODO: Does whitelist matching actually work?
                if(whitelistMatcher.matchesAny(msg.urls[i], msg.types[i], msg.domain, false))
                    continue;
                //var f;
                // TODO: Implement thirdParty check
                if(blacklistMatcher.matchesAny(msg.urls[i], msg.types[i], msg.domain, true)) {
                    blockList.push(msg.serials[i]);
                }
            }
            port.postMessage({shouldBlockList: blockList});
        }
    });
});

var lastTabId = 0;
chrome.extension.onRequest.addListener(function(request, sender, sendResponse) {
    if(request.reqtype == "get-elemhide-selectors") {
        var selectors = abp.elemhide.getSelectorsToHide(request.domain);
        sendResponse({selectors: selectors});
    } else if(request.reqtype == "get-initialhide-options") {
        var selectors = null;
        var domain = sender.tab ? extractDomainFromURL(sender.tab.url) : "";
        var shouldInject = true;
        var enabled = sender.tab ? !isDomainExcluded(domain) : true;
        if(enabled) {
            if(domain in onlyInjectDomainSpecificSelectors) {
                selectors = abp.elemhide.getDomainSpecificSelectorsToHide(domain);
            } else
                selectors = abp.elemhide.getSelectorsToHide(domain);
            if(isDomainInList(domain, "noCSSInjectDomains"))
                shouldInject = false;
        }
        sendResponse({initialHideFlash: localStorage["initialHideFlash"] == "true", initialHideImg: localStorage["initialHideImg"] == "true", initialHideIframe: localStorage["initialHideIframe"] == "true", selectors: selectors, enabled: enabled, shouldInject: shouldInject});
    } else if(request.reqtype == "get-localstorage-option") {
        sendResponse({value: localStorage[request.name]});
    } else if(request.reqtype == "set-domain-enabled-state") {
        // Enable/disable ad blocking for a particular domain
        chrome.tabs.get(lastTabId, function(tab) {
            if(!tab) return;
            var domain = extractDomainFromURL(tab.url);
            if(request.enabled)
                removeDomainFromExclusionList(domain);
            else
                addDomainToExclusionList(domain);
            refreshIcon(tab);
        });
    } else if(request.reqtype == "get-domain-enabled-state") {
        // Returns whether this domain is in the exclusion list.
        // The page action popup asks us this.
        if(sender.tab) {
            sendResponse({enabled: !isDomainExcluded(extractDomainFromURL(sender.tab.url)), specialCaseYouTube: localStorage["specialCaseYouTube"] == "true"});
            return;
        }
        chrome.tabs.get(lastTabId, function(tab) {
            if(!tab) return;
            sendResponse({enabled: !isDomainExcluded(extractDomainFromURL(tab.url))});
        });
    } else if(request.reqtype == "refresh-page-icon") {
        // Show page icon according to the user option
        refreshIconByTabId(lastTabId);
    } else if(request.reqtype == "reload-filters") {
        // Reloads filter lists and user filters
        reloadFilters();
    } else if(request.reqtype == "cache-filters") {
        clickHideFilters = request.filters;
    } else if(request.reqtype == "apply-cached-filters") {
        // Cached filters are from click to hide
        for(var i = 0; i < clickHideFilters.length; i++)
            addFilter(clickHideFilters[i]);
        clickHideFilters = null; // clear them for next time around
    } else if(request.reqtype == "set-clickhide-active") {
        clickHideActive = request.active;
    } else if(request.reqtype == "get-cached-filters") {
        // Popup is asking for ABP filters constructed from whatever the user 
        // chose during clickHide
        sendResponse({filters: clickHideFilters, active: clickHideActive});
    } else {
        sendResponse({comment: "Something broke! (Unknown message)"}); // allow cleanup of listener
    }
});

// Show icon as page action
chrome.tabs.onSelectionChanged.addListener(function(tabId) {
    lastTabId = tabId;
    refreshIconByTabId(tabId);

    // Also, cancel any pending click hide stuff
    clickHideFilters = null;
    chrome.tabs.sendRequest(tabId, {reqtype: "clickhide-deactivate"})
});

chrome.tabs.onUpdated.addListener(function(tabId, changeInfo, tab) {
    lastTabId = tabId;
    
    if(changeInfo.status == "complete") refreshIcon(tab);
});

// Show page action on current tab
chrome.tabs.getSelected(null, function(tab) {
    if(!tab) return;
    lastTabId = tab.id;
    refreshIcon(tab);
});

// Reload filters every four hours, which will trigger the autoupdate
setInterval(reloadFilters, 4 * 60 * 60 * 1000);

</script>
</html>
